[{"id":"93a7624f-13f2-4c21-b7f9-db3650d07035","userId":"64e066d2-aa76-4c86-9b69-45e5a8395be1","tool":{"id":"sql_server_access","name":"SQL Server Access","meta":{"description":"A tool for reading database information and executing SQL queries, supporting multiple databases such as MySQL, PostgreSQL, SQLite, and Oracle. It provides functionalities for listing all tables, describing table schemas, and returning query results in CSV format. A versatile DB Agent for seamless database interactions.","manifest":{"title":"SQL Server Access","author":"MENG","author_urls":"","description":"A tool for reading database information and executing SQL queries, supporting multiple databases such as MySQL, PostgreSQL, SQLite, and Oracle. It provides functionalities for listing all tables, describing table schemas, and returning query results in CSV format. A versatile DB Agent for seamless database interactions.","required_open_webui_version":"0.5.4","requirements":"pymysql, sqlalchemy, cx_Oracle","version":"0.1.6","licence":"MIT"}},"content":"\"\"\"\ntitle: SQL Server Access\nauthor: MENG\nauthor_urls:\n  - https://github.com/mengvision\ndescription: A tool for reading database information and executing SQL queries, supporting multiple databases such as MySQL, PostgreSQL, SQLite, and Oracle. It provides functionalities for listing all tables, describing table schemas, and returning query results in CSV format. A versatile DB Agent for seamless database interactions.\nrequired_open_webui_version: 0.5.4\nrequirements: pymysql, sqlalchemy, cx_Oracle\nversion: 0.1.6\nlicence: MIT\n\n# Changelog\n## [0.1.6] - 2025-03-11\n### Added\n- Added `get_table_indexes` method to retrieve index information for a specific table, supporting MySQL, PostgreSQL, SQLite, and Oracle.\n- Enhanced metadata capabilities by providing detailed index descriptions (e.g., index name, columns, and type).\n- Improved documentation to include the new `get_table_indexes` method and its usage examples.\n- Updated error handling in `get_table_indexes` to provide more detailed feedback for unsupported database types.\n\n## [0.1.5] - 2025-01-20\n### Changed\n- Updated `list_all_tables` and `table_data_schema` methods to accept `db_name` as a function parameter instead of using `self.valves.db_name`.\n- Improved flexibility by decoupling database name from class variables, allowing dynamic database selection at runtime.\n\n## [0.1.4] - 2025-01-17\n### Added\n- Added support for Oracle database using `cx_Oracle` driver.\n- Added dynamic engine creation in each method to ensure fresh database connections for every operation.\n- Added support for Oracle-specific queries in `list_all_tables` and `table_data_schema` methods.\n\n### Changed\n- Moved `self._get_engine()` from `__init__` to individual methods for better flexibility and tool compatibility.\n- Updated `_get_engine` method to support Oracle database connection URL.\n- Improved `table_data_schema` method to handle Oracle-specific column metadata.\n\n### Fixed\n- Fixed potential connection issues by ensuring each method creates its own database engine.\n- Improved error handling for Oracle-specific queries and edge cases.\n\n## [0.1.3] - 2025-01-17\n### Added\n- Added support for multiple database types (e.g., MySQL, PostgreSQL, SQLite) using SQLAlchemy.\n- Added configuration flexibility through environment variables or external configuration files.\n- Enhanced query security with stricter validation and SQL injection prevention.\n- Improved error handling with detailed exception messages for better debugging.\n\n### Changed\n- Replaced `pymysql` with SQLAlchemy for broader database compatibility.\n- Abstracted database connection logic into a reusable `_get_engine` method.\n- Updated `table_data_schema` method to support multiple database types.\n\n### Fixed\n- Fixed potential SQL injection vulnerabilities in query execution.\n- Improved handling of edge cases in query validation and execution.\n\n## [0.1.2] - 2025-01-16\n### Added \n- Added support for specifying the database port with a default value of `3306`. \n- Abstracted database connection logic into a reusable `_get_connection` method. \n\n## [0.1.1] - 2025-01-16\n### Added\n- Support for additional read-only query types: `SHOW`, `DESCRIBE`, `EXPLAIN`, and `USE`.\n- Enhanced query validation to block sensitive keywords (e.g., `INSERT`, `UPDATE`, `DELETE`, `CREATE`, `DROP`, `ALTER`).\n\n### Fixed\n- Improved handling of queries starting with `WITH` (CTE queries).\n- Fixed case sensitivity issues in query validation.\n\n## [0.1.0] - 2025-01-09\n### Initial Release\n- Basic functionality for listing tables, describing table schemas, and executing `SELECT` queries.\n- Query results returned in CSV format.\n\"\"\"\n\nimport os\nfrom typing import List, Dict, Any\nfrom pydantic import BaseModel, Field\nimport re\nfrom sqlalchemy import create_engine, text\nfrom sqlalchemy.engine.base import Engine\nfrom sqlalchemy.exc import SQLAlchemyError\n\n\nclass Tools:\n    class Valves(BaseModel):\n        db_host: str = Field(\n            default=\"localhost\",\n            description=\"The host of the database. Replace with your own host.\",\n        )\n        db_user: str = Field(\n            default=\"admin\",\n            description=\"The username for the database. Replace with your own username.\",\n        )\n        db_password: str = Field(\n            default=\"admin\",\n            description=\"The password for the database. Replace with your own password.\",\n        )\n        db_name: str = Field(\n            default=\"db\",\n            description=\"The name of the database. Replace with your own database name.\",\n        )\n        db_port: int = Field(\n            default=3306,  # Oracle 默认端口\n            description=\"The port of the database. Replace with your own port.\",\n        )\n        db_type: str = Field(\n            default=\"mysql\",\n            description=\"The type of the database (e.g., mysql, postgresql, sqlite, oracle).\",\n        )\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Tools class with the credentials for the database.\n        \"\"\"\n        print(\"Initializing database tool class\")\n        self.citation = True\n        self.valves = Tools.Valves()\n\n    def _get_engine(self) -> Engine:\n        \"\"\"\n        Create and return a database engine using the current configuration.\n        \"\"\"\n        if self.valves.db_type == \"mysql\":\n            db_url = f\"mysql+pymysql://{self.valves.db_user}:{self.valves.db_password}@{self.valves.db_host}:{self.valves.db_port}/{self.valves.db_name}\"\n        elif self.valves.db_type == \"postgresql\":\n            db_url = f\"postgresql://{self.valves.db_user}:{self.valves.db_password}@{self.valves.db_host}:{self.valves.db_port}/{self.valves.db_name}\"\n        elif self.valves.db_type == \"sqlite\":\n            db_url = f\"sqlite:///{self.valves.db_name}\"\n        elif self.valves.db_type == \"oracle\":\n            db_url = f\"oracle+cx_oracle://{self.valves.db_user}:{self.valves.db_password}@{self.valves.db_host}:{self.valves.db_port}/?service_name={self.valves.db_name}\"\n        else:\n            raise ValueError(f\"Unsupported database type: {self.valves.db_type}\")\n\n        return create_engine(db_url)\n\n    def list_all_tables(self, db_name: str) -> str:\n        \"\"\"\n        List all tables in the database.\n        :param db_name: The name of the database.\n        :return: A string containing the names of all tables.\n        \"\"\"\n        print(\"Listing all tables in the database\")\n        engine = self._get_engine()  # 动态创建引擎\n        try:\n            with engine.connect() as conn:\n                if self.valves.db_type == \"mysql\":\n                    result = conn.execute(text(\"SHOW TABLES;\"))\n                elif self.valves.db_type == \"postgresql\":\n                    result = conn.execute(\n                        text(\n                            \"SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';\"\n                        )\n                    )\n                elif self.valves.db_type == \"sqlite\":\n                    result = conn.execute(\n                        text(\"SELECT name FROM sqlite_master WHERE type='table';\")\n                    )\n                elif self.valves.db_type == \"oracle\":\n                    result = conn.execute(text(\"SELECT table_name FROM user_tables;\"))\n                else:\n                    return \"Unsupported database type.\"\n                tables = [row[0] for row in result.fetchall()]\n                if tables:\n                    return (\n                        \"Here is a list of all the tables in the database:\\n\\n\"\n                        + \"\\n\".join(tables)\n                    )\n                else:\n                    return \"No tables found.\"\n        except SQLAlchemyError as e:\n            return f\"Error listing tables: {str(e)}\"\n\n    def get_table_indexes(self, db_name: str, table_name: str) -> str:\n        \"\"\"\n        Get the indexes of a specific table in the database.\n        :param db_name: The name of the database.\n        :param table_name: The name of the table.\n        :return: A string describing the indexes of the table.\n        \"\"\"\n        print(f\"Getting indexes for table: {table_name}\")\n        engine = self._get_engine()\n        try:\n            with engine.connect() as conn:\n                if self.valves.db_type == \"mysql\":\n                    query = text(\n                        \"\"\"\n                        SHOW INDEX FROM :table_name;\n                        \"\"\"\n                    )\n                elif self.valves.db_type == \"postgresql\":\n                    query = text(\n                        \"\"\"\n                        SELECT indexname, indexdef\n                        FROM pg_indexes\n                        WHERE tablename = :table_name;\n                        \"\"\"\n                    )\n                elif self.valves.db_type == \"sqlite\":\n                    query = text(\n                        \"\"\"\n                        PRAGMA index_list(:table_name);\n                        \"\"\"\n                    )\n                elif self.valves.db_type == \"oracle\":\n                    query = text(\n                        \"\"\"\n                        SELECT index_name, column_name\n                        FROM user_ind_columns\n                        WHERE table_name = :table_name;\n                        \"\"\"\n                    )\n                else:\n                    return \"Unsupported database type.\"\n                result = conn.execute(query, {\"table_name\": table_name})\n                indexes = result.fetchall()\n                if not indexes:\n                    return f\"No indexes found for table: {table_name}\"\n                description = f\"Indexes for table '{table_name}':\\n\"\n                for index in indexes:\n                    description += f\"- {index[0]}: {index[1]}\\n\"\n                return description\n        except SQLAlchemyError as e:\n            return f\"Error getting indexes: {str(e)}\"\n    \n    def table_data_schema(self, db_name: str, table_name: str) -> str:\n        \"\"\"\n        Describe the schema of a specific table in the database, including column comments.\n        :param db_name: The name of the database.\n        :param table_name: The name of the table to describe.\n        :return: A string describing the data schema of the table.\n        \"\"\"\n        print(f\"Describing table: {table_name}\")\n        engine = self._get_engine()  # 动态创建引擎\n        try:\n            with engine.connect() as conn:\n                if self.valves.db_type == \"mysql\":\n                    query = text(\n                        \"\"\"\n                        SELECT COLUMN_NAME, COLUMN_TYPE, IS_NULLABLE, COLUMN_KEY, COLUMN_COMMENT\n                        FROM INFORMATION_SCHEMA.COLUMNS\n                        WHERE TABLE_SCHEMA = :db_name AND TABLE_NAME = :table_name;\n                    \"\"\"\n                    )\n                elif self.valves.db_type == \"postgresql\":\n                    query = text(\n                        \"\"\"\n                        SELECT column_name, data_type, is_nullable, column_default, ''\n                        FROM information_schema.columns\n                        WHERE table_name = :table_name;\n                    \"\"\"\n                    )\n                elif self.valves.db_type == \"sqlite\":\n                    query = text(\"PRAGMA table_info(:table_name);\")\n                elif self.valves.db_type == \"oracle\":\n                    query = text(\n                        \"\"\"\n                        SELECT column_name, data_type, nullable, data_default, comments\n                        FROM user_tab_columns\n                        LEFT JOIN user_col_comments\n                        ON user_tab_columns.table_name = user_col_comments.table_name\n                        AND user_tab_columns.column_name = user_col_comments.column_name\n                        WHERE user_tab_columns.table_name = :table_name;\n                    \"\"\"\n                    )\n                else:\n                    return \"Unsupported database type.\"\n                result = conn.execute(\n                    query, {\"db_name\": db_name, \"table_name\": table_name}\n                )\n                columns = result.fetchall()\n                if not columns:\n                    return f\"No such table: {table_name}\"\n                description = (\n                    f\"Table '{table_name}' in the database has the following columns:\\n\"\n                )\n                for column in columns:\n                    if self.valves.db_type == \"sqlite\":\n                        column_name, data_type, is_nullable, _, _, _ = column\n                        column_comment = \"\"\n                    elif self.valves.db_type == \"oracle\":\n                        (\n                            column_name,\n                            data_type,\n                            is_nullable,\n                            data_default,\n                            column_comment,\n                        ) = column\n                    else:\n                        (\n                            column_name,\n                            data_type,\n                            is_nullable,\n                            column_key,\n                            column_comment,\n                        ) = column\n                    description += f\"- {column_name} ({data_type})\"\n                    if is_nullable == \"YES\" or is_nullable == \"Y\":\n                        description += \" [Nullable]\"\n                    if column_key == \"PRI\":\n                        description += \" [Primary Key]\"\n                    if column_comment:\n                        description += f\" [Comment: {column_comment}]\"\n                    description += \"\\n\"\n                return description\n        except SQLAlchemyError as e:\n            return f\"Error describing table: {str(e)}\"\n\n    def execute_read_query(self, query: str) -> str:\n        \"\"\"\n        Execute a read query and return the result in CSV format.\n        :param query: The SQL query to execute.\n        :return: A string containing the result of the query in CSV format.\n        \"\"\"\n        print(f\"Executing query: {query}\")\n        normalized_query = query.strip().lower()\n        if not re.match(\n            r\"^\\s*(select|with|show|describe|desc|explain|use)\\s\", normalized_query\n        ):\n            return \"Error: Only read-only queries (SELECT, WITH, SHOW, DESCRIBE, EXPLAIN, USE) are allowed. CREATE, DELETE, INSERT, UPDATE, DROP, and ALTER operations are not permitted.\"\n\n        sensitive_keywords = [\n            \"insert\",\n            \"update\",\n            \"delete\",\n            \"create\",\n            \"drop\",\n            \"alter\",\n            \"truncate\",\n            \"grant\",\n            \"revoke\",\n            \"replace\",\n        ]\n        for keyword in sensitive_keywords:\n            if re.search(rf\"\\b{keyword}\\b\", normalized_query):\n                return f\"Error: Query contains a sensitive keyword '{keyword}'. Only read operations are allowed.\"\n\n        engine = self._get_engine()  # 动态创建引擎\n        try:\n            with engine.connect() as conn:\n                result = conn.execute(text(query))\n                rows = result.fetchall()\n                if not rows:\n                    return \"No data returned from query.\"\n\n                column_names = result.keys()\n                csv_data = f\"Query executed successfully. Below is the actual result of the query {query} running against the database in CSV format:\\n\\n\"\n                csv_data += \",\".join(column_names) + \"\\n\"\n                for row in rows:\n                    csv_data += \",\".join(map(str, row)) + \"\\n\"\n                return csv_data\n        except SQLAlchemyError as e:\n            return f\"Error executing query: {str(e)}\"\n"},"downloads":1221,"upvotes":0,"downvotes":0,"updatedAt":1741662676,"createdAt":1736927141,"user":{"id":"64e066d2-aa76-4c86-9b69-45e5a8395be1","username":"mengvision","name":"","profileImageUrl":"https://www.gravatar.com/avatar/76007c930025bb6366c1f3dc933cd24e96cb001e1ac63b6c66c80e4ab1e4e398?d=mp","createdAt":1736925884}}]