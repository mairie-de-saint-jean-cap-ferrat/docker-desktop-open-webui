[{"id":"f951d7b7-c1a9-4970-b540-4bfabf6672e6","userId":"e94373e2-f00a-4e2f-8da0-e00bb6359900","tool":{"id":"memory","name":"Memory","meta":{"description":"Allow the model to autonomously save/modify/delete/read long-term memory.","manifest":{"title":"Memory","author":"https://github.com/CookSleep","version":"0.0.1","license":"MIT"}},"content":"\"\"\"\ntitle: Memory\nauthor: https://github.com/CookSleep\nversion: 0.0.1\nlicense: MIT\n\nThis tool supports a complete experience when using OpenAI API \n(and any API fully compatible with OpenAI API format) or Gemini models \nin native Function Calling mode.\n\nIf the API format is not supported, you can still use the default \nFunction Calling mode, but the experience will be significantly reduced.\n\nThis tool is an improved version of https://openwebui.com/t/mhio/met, \nfully utilizing Open WebUI's native memory functionality.\n\nYou don't need to enable the memory switch, \nas this tool only requires access to its database.\n\"\"\"\n\nimport json\nfrom typing import Callable, Any, List\n\nfrom open_webui.models.memories import Memories\nfrom pydantic import BaseModel, Field\n\n\nclass EventEmitter:\n    def __init__(self, event_emitter: Callable[[dict], Any] = None):\n        self.event_emitter = event_emitter\n\n    async def emit(self, description=\"Unknown state\", status=\"in_progress\", done=False):\n        \"\"\"\n        Send a status event to the event emitter.\n\n        :param description: Event description\n        :param status: Event status\n        :param done: Whether the event is complete\n        \"\"\"\n        if self.event_emitter:\n            await self.event_emitter(\n                {\n                    \"type\": \"status\",\n                    \"data\": {\n                        \"status\": status,\n                        \"description\": description,\n                        \"done\": done,\n                    },\n                }\n            )\n\n\n# Pydantic model for memory update operations\nclass MemoryUpdate(BaseModel):\n    index: int = Field(..., description=\"Index of the memory entry (1-based)\")\n    content: str = Field(..., description=\"Updated content for the memory\")\n\n\nclass Tools:\n    \"\"\"\n    Memory\n\n    Use this tool to autonomously save/modify/query memories across conversations.\n\n    IMPORTANT: Users rarely explicitly tell you what to remember!\n    You must actively observe and identify important information that should be stored.\n\n    Key features:\n    1. Proactive memory creation: Identify user preferences, project context, and recurring patterns\n    2. Intelligent memory usage: Reference stored information without requiring users to repeat themselves\n    3. Best practices: Store valuable information, maintain relevance, provide memories at appropriate times\n    4. Language matching: Always create memories in the user's preferred language and writing style\n\n    IMPORTANT NOTE ON CLEARING MEMORIES:\n    If a user asks to clear all memories, DO NOT attempt to implement this via code.\n    Instead, inform them that clearing all memories is a high-risk operation that\n    should be performed through their personal account settings panel using the\n    \"Clear All Memories\" button. This prevents accidental data loss.\n    \"\"\"\n\n    class Valves(BaseModel):\n        USE_MEMORY: bool = Field(\n            default=True, description=\"Enable or disable memory usage.\"\n        )\n        DEBUG: bool = Field(default=True, description=\"Enable or disable debug mode.\")\n\n    def __init__(self):\n        \"\"\"Initialize the memory management tool.\"\"\"\n        self.valves = self.Valves()\n\n    async def recall_memories(\n        self, __user__: dict = None, __event_emitter__: Callable[[dict], Any] = None\n    ) -> str:\n        \"\"\"\n        Retrieves all stored memories from the user's memory vault.\n\n        IMPORTANT: Proactively check memories to enhance your responses!\n        Don't wait for users to ask what you remember.\n\n        Returns memories in chronological order with index numbers.\n        Use when you need to check stored information, reference previous\n        preferences, or build context for responses.\n\n        :param __user__: User dictionary containing the user ID\n        :param __event_emitter__: Optional event emitter for tracking status\n        :return: JSON string with indexed memories list\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n\n        if not __user__:\n            message = \"User ID not provided.\"\n            await emitter.emit(description=message, status=\"missing_user_id\", done=True)\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        user_id = __user__.get(\"id\")\n        if not user_id:\n            message = \"User ID not provided.\"\n            await emitter.emit(description=message, status=\"missing_user_id\", done=True)\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        await emitter.emit(\n            description=\"Retrieving stored memories.\",\n            status=\"recall_in_progress\",\n            done=False,\n        )\n\n        user_memories = Memories.get_memories_by_user_id(user_id)\n        if not user_memories:\n            message = \"No memory stored.\"\n            await emitter.emit(description=message, status=\"recall_complete\", done=True)\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        content_list = [\n            f\"{index}. {memory.content}\"\n            for index, memory in enumerate(\n                sorted(user_memories, key=lambda m: m.created_at), start=1\n            )\n        ]\n\n        await emitter.emit(\n            description=f\"{len(user_memories)} memories loaded\",\n            status=\"recall_complete\",\n            done=True,\n        )\n\n        return f\"Memories from the users memory vault: {content_list}\"\n\n    async def add_memory(\n        self,\n        input_text: List[\n            str\n        ],  # Modified to only accept list, JSON Schema items.type is string\n        __user__: dict = None,\n        __event_emitter__: Callable[[dict], Any] = None,\n    ) -> str:\n        \"\"\"\n        Adds one or more memories to the user's memory vault.\n\n        IMPORTANT: Don't wait for explicit instructions to remember!\n        Proactively identify and store important information.\n\n        Good candidates for memories:\n        - Personal preferences (favorite topics, entertainment, colors)\n        - Professional information (field of expertise, current projects)\n        - Important relationships (family, pets, close friends)\n        - Recurring needs or requests (common questions, regular workflows)\n        - Learning goals and interests (topics they're studying, skills they want to develop)\n\n        Always use the user's preferred language and writing style.\n\n        Memories should start with \"User\", for example:\n        - \"User likes blue\"\n        - \"User is a software engineer\"\n        - \"User has a golden retriever named Max\"\n\n        :param input_text: Single memory string or list of memory strings to store\n        :param __user__: User dictionary containing the user ID\n        :param __event_emitter__: Optional event emitter for tracking status\n        :return: JSON string with result message\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n        if not __user__:\n            message = \"User ID not provided.\"\n            await emitter.emit(description=message, status=\"missing_user_id\", done=True)\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        user_id = __user__.get(\"id\")\n        if not user_id:\n            message = \"User ID not provided.\"\n            await emitter.emit(description=message, status=\"missing_user_id\", done=True)\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        # Handle single string input if needed\n        if isinstance(input_text, str):\n            input_text = [input_text]\n\n        await emitter.emit(\n            description=\"Adding entries to the memory vault.\",\n            status=\"add_in_progress\",\n            done=False,\n        )\n\n        # Process each memory item\n        added_items = []\n        failed_items = []\n\n        for item in input_text:\n            new_memory = Memories.insert_new_memory(user_id, item)\n            if new_memory:\n                added_items.append(item)\n            else:\n                failed_items.append(item)\n\n        if not added_items:\n            message = \"Failed to add any memories.\"\n            await emitter.emit(description=message, status=\"add_failed\", done=True)\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        # Prepare result message\n        added_count = len(added_items)\n        failed_count = len(failed_items)\n\n        if failed_count > 0:\n            message = (\n                f\"Added {added_count} memories, failed to add {failed_count} memories.\"\n            )\n        else:\n            message = f\"Successfully added {added_count} memories.\"\n\n        await emitter.emit(\n            description=message,\n            status=\"add_complete\",\n            done=True,\n        )\n        return json.dumps({\"message\": message}, ensure_ascii=False)\n\n    async def delete_memory(\n        self,\n        indices: List[int],  # Modified to only accept list, items.type is integer\n        __user__: dict = None,\n        __event_emitter__: Callable[[dict], Any] = None,\n    ) -> str:\n        \"\"\"\n        Delete one or more memory entries from the user's memory vault.\n\n        Use to remove outdated or incorrect memories.\n\n        For single deletion: provide an integer index\n        For multiple deletions: provide a list of integer indices\n\n        Indices refer to the position in the sorted list (1-based).\n\n        :param indices: Single index (int) or list of indices to delete\n        :param __user__: User dictionary containing the user ID\n        :param __event_emitter__: Optional event emitter\n        :return: JSON string with result message\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n\n        if not __user__:\n            message = \"User ID not provided.\"\n            await emitter.emit(description=message, status=\"missing_user_id\", done=True)\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        user_id = __user__.get(\"id\")\n        if not user_id:\n            message = \"User ID not provided.\"\n            await emitter.emit(description=message, status=\"missing_user_id\", done=True)\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        # Handle single integer input if needed\n        if isinstance(indices, int):\n            indices = [indices]\n\n        await emitter.emit(\n            description=f\"Deleting {len(indices)} memory entries.\",\n            status=\"delete_in_progress\",\n            done=False,\n        )\n\n        # Get all memories for this user\n        user_memories = Memories.get_memories_by_user_id(user_id)\n        if not user_memories:\n            message = \"No memories found to delete.\"\n            await emitter.emit(description=message, status=\"delete_failed\", done=True)\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        sorted_memories = sorted(user_memories, key=lambda m: m.created_at)\n        responses = []\n\n        for index in indices:\n            if index < 1 or index > len(sorted_memories):\n                message = f\"Memory index {index} does not exist.\"\n                responses.append(message)\n                await emitter.emit(\n                    description=message, status=\"delete_failed\", done=False\n                )\n                continue\n\n            # Get the memory by index (1-based index)\n            memory_to_delete = sorted_memories[index - 1]\n\n            # Delete the memory\n            result = Memories.delete_memory_by_id(memory_to_delete.id)\n            if not result:\n                message = f\"Failed to delete memory at index {index}.\"\n                responses.append(message)\n                await emitter.emit(\n                    description=message, status=\"delete_failed\", done=False\n                )\n            else:\n                message = f\"Memory at index {index} deleted successfully.\"\n                responses.append(message)\n                await emitter.emit(\n                    description=message, status=\"delete_success\", done=False\n                )\n\n        await emitter.emit(\n            description=\"All requested memory deletions have been processed.\",\n            status=\"delete_complete\",\n            done=True,\n        )\n        return json.dumps({\"message\": \"\\n\".join(responses)}, ensure_ascii=False)\n\n    async def update_memory(\n        self,\n        updates: List[\n            MemoryUpdate\n        ],  # Modified to accept list of MemoryUpdate objects, items.type is object\n        __user__: dict = None,\n        __event_emitter__: Callable[[dict], Any] = None,\n    ) -> str:\n        \"\"\"\n        Update one or more memory entries in the user's memory vault.\n\n        Use to modify existing memories when information changes.\n\n        For single update: provide a dict with 'index' and 'content' keys\n        For multiple updates: provide a list of dicts with 'index' and 'content' keys\n\n        The 'index' refers to the position in the sorted list (1-based).\n\n        Common scenarios: Correcting information, adding details,\n        updating preferences, or refining wording.\n\n        :param updates: Dict with 'index' and 'content' keys OR a list of such dicts\n        :param __user__: User dictionary containing the user ID\n        :param __event_emitter__: Optional event emitter\n        :return: JSON string with result message\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n\n        if not __user__:\n            message = \"User ID not provided.\"\n            await emitter.emit(description=message, status=\"missing_user_id\", done=True)\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        user_id = __user__.get(\"id\")\n        if not user_id:\n            message = \"User ID not provided.\"\n            await emitter.emit(description=message, status=\"missing_user_id\", done=True)\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        await emitter.emit(\n            description=f\"Updating {len(updates)} memory entries.\",\n            status=\"update_in_progress\",\n            done=False,\n        )\n\n        # Get all memories for this user\n        user_memories = Memories.get_memories_by_user_id(user_id)\n        if not user_memories:\n            message = \"No memories found to update.\"\n            await emitter.emit(description=message, status=\"update_failed\", done=True)\n            return json.dumps({\"message\": message}, ensure_ascii=False)\n\n        sorted_memories = sorted(user_memories, key=lambda m: m.created_at)\n        responses = []\n\n        for update_item in updates:\n            # Convert dict to MemoryUpdate object if needed\n            if isinstance(update_item, dict):\n                try:\n                    update_item = MemoryUpdate.parse_obj(update_item)\n                except Exception as e:\n                    message = f\"Invalid update item format: {update_item}\"\n                    responses.append(message)\n                    await emitter.emit(\n                        description=message, status=\"update_failed\", done=False\n                    )\n                    continue\n\n            index = update_item.index\n            content = update_item.content\n\n            if index < 1 or index > len(sorted_memories):\n                message = f\"Memory index {index} does not exist.\"\n                responses.append(message)\n                await emitter.emit(\n                    description=message, status=\"update_failed\", done=False\n                )\n                continue\n\n            # Get the memory by index (1-based index)\n            memory_to_update = sorted_memories[index - 1]\n\n            # Update the memory\n            updated_memory = Memories.update_memory_by_id(memory_to_update.id, content)\n            if not updated_memory:\n                message = f\"Failed to update memory at index {index}.\"\n                responses.append(message)\n                await emitter.emit(\n                    description=message, status=\"update_failed\", done=False\n                )\n            else:\n                message = f\"Memory at index {index} updated successfully.\"\n                responses.append(message)\n                await emitter.emit(\n                    description=message, status=\"update_success\", done=False\n                )\n\n        await emitter.emit(\n            description=\"All requested memory updates have been processed.\",\n            status=\"update_complete\",\n            done=True,\n        )\n        return json.dumps({\"message\": \"\\n\".join(responses)}, ensure_ascii=False)\n"},"downloads":299,"upvotes":0,"downvotes":0,"updatedAt":1741623673,"createdAt":1741623673,"user":{"id":"e94373e2-f00a-4e2f-8da0-e00bb6359900","username":"cooksleep","name":"","profileImageUrl":"https://www.gravatar.com/avatar/02e4ef3f5d408960c7f085426b4aaf96f4ad2360fd258e8442e5392ce1195d63?d=mp","createdAt":1722787891}}]